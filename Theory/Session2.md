## Q: What is `NPM`?
A:npm is a tool that helps developers easily manage and install reusable code packages, called "packages" or "modules", from a centralized registry. These packages contain pre-written JavaScript code that provides specific functionality, such as libraries, frameworks, utilities, or tools. npm allows developers to leverage these packages in their own projects, saving time and effort by reusing existing code.
- `npm` alternative is `yarn`

### How to initialize `npm`?
```
npm init
```
`npm init -y` can be used to skip the setup step, `npm` takes care of it and creates the `package.json` json file automatically , but without configurations.

The package.json file serves as a configuration file for your project and contains important information such as project metadata, dependencies, scripts, and more.

## Q: What is `NPX`?
Npx is a tool that use to execute packages.

## Q: Difference between `NPM` and `NPM`?
When you use `npm`, it looks for the packages you need in a central repository. It finds and installs the packages based on the dependencies specified in your project's configuration file. `npx`, on the other hand, first checks if the required package is already available locally. If not found, it fetches the latest version from the repository temporarily, `just for the current use.`

## Q: What is `npm install <package name>`  ?

The command `npm install <package name>` is used to install a specific package from the npm registry into your project. When you run this command, npm will perform the following actions:

- `Check the npm registry`: npm will search the npm registry for the 
  specified package name.

- `Download the package`: If the package is found in the registry, npm will 
   download the package and any required dependencies associated with it.

- `Save the package`: The downloaded package and its dependencies will be 
   saved in the node_modules folder of your project directory.

-  `Update package.json and package-lock.json`: npm will update your 
    project's package.json file to include the installed package as a 
    dependency. If a package-lock.json file exists, it will also be updated 
    to record the specific version of the installed package and its 
    dependencies.

 ## Q: What is `npm install`?

Here's how the `npm install` command works:

- It reads the package.json file in your project to determine the required packages and their versions.

- It contacts the npm registry, which is a centralized repository of open-source JavaScript packages.

- It downloads the specified packages and their dependencies from the registry and saves them in a node_modules folder within your project's directory.

- It creates or updates a package-lock.json file, which records the exact versions of the installed packages and their dependencies. This file ensures consistent and 
  reproducible installations across different environments.

## Q: What is `node-module`?
The `node_modules` directory acts as a local repository where all the installed packages are stored. Each package is typically placed in its own folder within the node_modules directory, allowing for easy organization and management of dependencies.

## Q: Should we put node_module in gitignore?
Yes, node_modules directory can become quite large, especially for projects with numerous dependencies. However, you typically don't need to include the node_modules directory when sharing your project with others. Instead, you can simply provide the package.json and package-lock.json files, which allow others to install the same set of dependencies by running npm install in their own environments.node_module can be regenerated on server by excecuting npm install

## Q: Should we put `package.json` and `package-lock.json in gitignore?
No,
## NOTE:-
The basic idea is that, things which we can regenerate on server are to be kept in gitignore file.

## Q: What is `package.json` and `package-lock.json`?
`package.json:`
package.json is a metadata file that contains information about your project and its dependencies.
- It includes details such as the project name, version, description, entry point, scripts, dependencies, devDependencies, and more.
- You can create a package.json file by running `npm init` or by manually creating and configuring it.
- It is typically committed to version control (e.g., Git) and included when sharing your project.

`package-lock.json:`
package-lock.json is a file automatically generated by npm to provide deterministic and reproducible builds.
- It includes detailed information about the exact versions of packages and their dependencies installed in your project.
- It ensures that the same versions of packages are installed consistently across different environments or by different developers.
- It also takes into account the `dependency tree`, including `transitive dependencies` (dependencies of dependencies), to ensure `consistency`.
- It includes `resolved versions`, `integrity hashes`, and other metadata for each installed package.
- It is created or updated automatically whenever you run `npm install` or `npm update`.
- It helps prevent unexpected changes in your project's dependencies by locking them down to specific versions.
- It should be committed to version control to maintain consistent builds across different environments.

```json
{
  "name": "my-project",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "dependencies": {
    "axios": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.21.1.tgz",
      "integrity": "sha512-ABC123...",
      "dependencies": {},
      "requires": {
        "follow-redirects": "^1.14.0"
      }
    },
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-XYZ456...",
      "dependencies": {},
      "requires": {
        "lodash.once": "^4.1.1",
        "lodash.uppercase": "^4.0.1"
      }
    }
  },
  "dependenciesMeta": {
    "axios": {
      "integrity": "sha512-ABC123...",
      "dependencies": {
        "follow-redirects": {
          "version": "1.14.1",
          "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.14.1.tgz",
          "integrity": "sha512-XYZ789..."
        }
      }
    },
    "lodash": {
      "integrity": "sha512-XYZ456...",
      "dependencies": {
        "lodash.once": {
          "version": "4.1.2",
          "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.2.tgz",
          "integrity": "sha512-UVW123..."
        },
        "lodash.uppercase": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/lodash.uppercase/-/lodash.uppercase-4.0.2.tgz",
          "integrity": "sha512-UVW456..."
        }
      }
    }
  }
}
```
`In this example:`

The dependencies section lists the direct dependencies (axios and lodash) of your project.
Each dependency entry includes the `version field`, which specifies the version of the package being used.
The `resolved field` contains the URL where the package is fetched from.
The `integrity fiel`d represents an integrity hash (checksum) of the package, ensuring its integrity and preventing tampering.
The `dependencies field` under each package entry captures any dependencies required by that package.
The `requires field` specifies the minimum version requirements for the listed dependencies.
The purpose of including the dependency tree, resolved versions, integrity hashes, and other metadata in package-lock.json is to ensure consistency and reproducibility when installing dependencies. 

`Dependency Tree`: The dependency tree captures the relationships between packages and their dependencies. It ensures that all necessary dependencies are installed correctly and in the correct order.

By including this information in package-lock.json, npm can accurately and reliably recreate the same dependency tree and install the exact versions of packages in any environment. This ensures that different developers working on the project or different deployment environments have consistent dependencies, reducing potential compatibility issues and ensuring reproducibility.

=============================================================
## Note:-
## Never ever i will touch node modules and package-lock.json
==============================================================

## Q: What is ~ and ^  in version of dependencies`?
In the context of specifying versions for dependencies in package.json files, the symbols ~ (tilde) and ^ (caret) are used as prefix modifiers to define version ranges. Here's what they mean:

When you specify a version using the `tilde (~)` symbol, it signifies a version range that allows patch-level updates.
For example, if you have a dependency specified as "lodash": "~4.17.1", it means any version of lodash in the 4.17.x range is acceptable.
More specifically, it allows updates to the patch-level version (the third number in the version string). 

When you specify a version using the `caret (^)` symbol, it signifies a version range that allows backward-compatible(compatible with older version) updates.
For example, if you have a dependency specified as "lodash": "^4.17.1", it means any version of lodash in the 4.x.x range is acceptable.
More specifically, it allows updates to the minor version (the second number in the version string). 

## Q: What are `dependency`,`devDependency`,`peerDependency`?

`Dependencies`:
Dependencies are packages that your project relies on for its functionality and runtime operation.

## Example:-
```json
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "react": "^17.0.2",
    "axios": "~0.21.1",
    "lodash": "4.17.21"
  }
}
```

`devDependencies`:
devDependencies are packages that are only required during the development and testing phases of your project.
These packages are not necessary for the actual runtime operation of your application but are used for development-specific tasks such as building, testing, linting, and debugging.
devDependencies are specified in the devDependencies section of your package.json file.
## Note:-
When you run npm install or yarn install with the --dev flag, only the devDependencies are installed.
These packages are typically excluded when deploying or sharing your project, as they are not needed in the production environment.
Examples of devDependencies may include testing frameworks (e.g., Jest), build tools (e.g., Babel or Webpack), code linters, or other development-specific utilities.
peerDependencies:

## Example:-
```json
{
  "name": "my-app",
  "version": "1.0.0",
  "devDependencies": {
    "jest": "^27.0.5",
    "eslint": "~7.32.0",
    "babel-core": "6.26.3"
  }
}
```
`peerDependencies`:


Suppose you are developing a library called my-library that provides React components. However, your library requires a specific version of React to function correctly. You don't want to include React as a direct dependency within my-library because you want the consumer of your library to have the flexibility to choose their own version of React. In this case, you would specify React as a peer dependency.

```json
{
  "name": "my-library",
  "version": "1.0.0",
  "peerDependencies": {
    "react": "^16.0.0"
  }
}
```
In this example, my-library declares a peer dependency on React with a version range of ^16.0.0. It means that any compatible version of React in the 16.x.x range is expected to be installed separately by the consumer.

When a user installs my-library as a dependency in their own project, they will also need to install React as a direct dependency in their project. The consumer's project might have a different version of React installed, as long as it falls within the specified range (^16.0.0 in this case).

## Q: What is Bundlers?

A bundler is a tool used in web development to package, combine,optimize, and manage various assets and code files,such as JavaScript files, CSS stylesheets, images, and more, into a more efficient and manageable form. It simplifies the process of organizing and delivering web applications by combining multiple files into a single optimized bundle. 

- `Bundling:` The bundler collects all your code files, such as JavaScript, CSS, and HTML, along with their dependencies, and bundles them together into a single file or multiple files. This makes it easier to share and deploy your application.

- `Minifying:` Bundlers can minimize the size of your code files by removing unnecessary spaces, comments, and renaming variables,console.logs. This helps reduce the file size, making your application load faster in the browser.

- `Cleaning Our Code:` Bundlers can perform code transformations and optimizations to improve the quality and efficiency of your code. They can remove unused code, detect and fix potential issues, and enforce coding conventions.

- `Dev and Production Build:` Bundlers support different build configurations, allowing you to create development and production builds. Development builds include additional features like source maps for easier debugging, while production builds are optimized for performance and have smaller file sizes.

- `Hot Module Replacement (HMR):` This feature allows you to make changes to your code while the application is running, and it automatically updates the affected modules without requiring a full page reload. It speeds up the development process and allows for real-time updates.

- `Image Optimization`: Bundlers can optimize images by compressing them without significant loss in quality. This reduces the file size of images, resulting in faster loading times and improved performance.

- `Caching while Development:` During development, bundlers can utilize caching mechanisms to improve build times. They intelligently determine which parts of the code have changed and only rebuild the necessary parts, avoiding unnecessary recompilation.

- `Compression:` Bundlers can compress files using techniques like gzip or brotli, which reduce the file size and improve network transfer speeds. This is particularly useful for optimizing assets like CSS and JavaScript files.

- `Compatibility`: Bundlers can transform your code to be compatible with older versions of web browsers, ensuring that your application works smoothly across a wide range of devices and browsers.

- `Zero Config:` Some bundlers, like Parcel, require minimal configuration. They automatically detect and handle dependencies, module resolution, and build optimizations, making it easier for developers to get started without complex setup processes.

- `HTTPS on Dev Machine`: Some bundlers, like Parcel, allow you to enable HTTPS on your local development server. This is useful for testing features that require secure connections.

           `npx parcel index.html --https`


- `Super Fast Build Algorithm`: Bundlers use efficient algorithms, often written in languages like C++, to optimize the build process. This helps reduce build times and improves developer productivity.

- `Uses Consistent Hashing Algorithm`: Bundlers use hashing algorithms to generate unique identifiers for modules. This ensures that the identifiers remain consistent, even if the content of the module changes, allowing for efficient caching and serving of the bundled files.

## Examples:-
Webpack,Parcel,RollUp,Vite,Browerify,SnowPack

## Q: What is Parcel?

Parcel is a modern web application bundler that has gained popularity for its simplicity
## Key Feature:-
- `Server Creation`: Parcel includes a built-in development server that allows you to serve your application during development without the need for an additional server 
   setup.

- `Hot Module Replacement (HMR)`: Parcel supports HMR, which means that any changes you make to your code will be instantly reflected in the browser without requiring a 
  full page reload. This speeds up the development process and provides a seamless experience.

- `File Watcher Algorithm`: Parcel uses a file watcher algorithm, inspired by the C++ filesystem API, to efficiently monitor changes in your project files. This ensures 
   that the bundling process is triggered only when necessary, reducing build times.

- `Bundling`: Parcel bundles your project files together into optimized bundles that can be served to the browser. It handles the dependency graph automatically, analyzing 
  import statements to include all necessary dependencies.

- `Minifying`: During the bundling process, Parcel minifies your code, removing unnecessary whitespace and reducing the size of the output bundles. This helps improve the 
   performance and load times of your application.

- `Cleaning Code`: Parcel has built-in code cleaning capabilities that can remove comments, debug statements, and other unused code during the bundling process. This helps 
  reduce the bundle size and improves the overall code cleanliness.

- `Dev and Production Builds`: Parcel supports both development and production builds. During development, Parcel focuses on fast bundling and providing features like HMR. 
   In production, it optimizes the bundles for better performance and adds additional optimizations, such as code splitting.

- `Super Fast Build Algorithm`: Parcel is known for its fast build times. It uses an optimized build algorithm that leverages caching, parallelization, and efficient 
   dependency resolution to speed up the bundling process.

- `Image Optimization`: Parcel includes image optimization capabilities, automatically optimizing images for web usage during the bundling process. This helps reduce the 
   size of image assets without sacrificing quality.

- `Caching While Development`: Parcel utilizes caching during development, allowing it to reuse previously built bundles when no changes have been made. This further 
  speeds up the development workflow by avoiding unnecessary rebuilds.

- `Compression`: Parcel supports compression techniques, such as Gzip and Brotli, to further reduce the size of the bundles and improve network transfer speeds.

- `Compatibility`: Parcel is designed to be compatible with older versions of browsers. It automatically adds necessary polyfills and fallbacks to ensure that your 
   application runs smoothly across a wide range of browser environments.

- `HTTPS on Dev Machine`: Parcel allows you to enable HTTPS on your local development server, which is useful for testing features that require secure connections. You can 
   enable HTTPS by running npx parcel index.html --https.

- `Consistent Hashing Algorithm`: Parcel uses a consistent hashing algorithm to generate unique file names for the output bundles. This ensures that the file names remain 
   consistent even when the content of the files changes, facilitating efficient caching and versioning.

- `Zero Configuration`: One of the key advantages of Parcel is its zero-configuration approach. It requires minimal to no configuration, allowing you to get started 
   quickly without spending time on complex setup steps.
`
## Q: What is `npm install -D parcel` or `npm install --save-dev parcel` and `npm install parcel` ?
Using npm install parcel -D or npm install parcel --save-dev installs parcel as a development dependency, while npm install parcel installs it as a regular dependency. The distinction between development and regular dependencies helps manage the dependencies more efficiently based on their purpose in your project.

## Q: What is npx parcel index.html  vs npm parcel index.html?
Suppose you have a project with Parcel installed as a development dependency (parcel) in your project's package.json file.
To bundle the index.html file using Parcel, you can run the following command in your project's directory:
`npx parcel index.html`
This will run the parcel command using the locally installed version of Parcel, bundling the index.html file as the entry point.
Example using npm run:

In your project's package.json file, you can define a script named "parcel" in the "scripts" section:
```json

"scripts": {
  "parcel": "parcel"
}
```
Save the changes in your package.json file.
To bundle the index.html file using Parcel, you can then run the following command in your project's directory:
`npm run parcel index.html`
This will execute the "parcel" script defined in the package.json file, running the parcel command with the index.html file as the argument.
In both cases, the result will be the same: Parcel will bundle the index.html file and generate the output files based on your project's configuration. The specific command to use depends on your setup and preferences, but both approaches achieve the goal of running Parcel to bundle the specified file.

## Q: What are .parcel-cache and dist folder and when they are created?

`.parcel-cache`:
The .parcel-cache folder is created or updated during the bundling process with Parcel.
- It is used as a caching mechanism to store intermediate build artifacts and dependencies.
- The folder is generated in the root directory of your project, alongside other project files.
- It stores cached data to improve subsequent build performance by avoiding reprocessing unchanged files and dependencies.
  dist (or build, output, etc.):

`The dist (or a similarly named) folder` is also created or updated during the bundling process.
- It serves as the output directory where Parcel generates the bundled and optimized files.
- The specific name and location of this folder can be configured in your project's Parcel configuration file (e.g., parcel.config.js).
- It contains the final bundled JavaScript, CSS, and other assets ready for deployment or serving in a production environment.

So, running `npx parcel index.html` triggers the creation of both the .parcel-cache and dist folders as part of the bundling process with Parcel.

## Q: Should we put .parcel-cache and dist folder in gitignore file?
It is generally recommended to include the .parcel-cache folder and the dist folder in your .gitignore file.  `.parcel-cache folder` and the `dist folder` can be easily regenerated by running the appropriate build command. i.e `npm parcel index.html`.

## Q: What is Browserlist?
Browserlist is a configuration file or a query string syntax that allows you to specify which browsers and versions your web application should support.
By specifying the last 2 versions, you ensure that your web application supports the most recent versions of major browsers without explicitly specifying each browser and version individually. This approach provides a good balance between supporting modern features and maintaining compatibility with older browsers.

## Q: Ways to create react app?
`Create React App (CRA):`
Create React App is a popular command-line tool that sets up a new React project with a pre-configured development environment. It provides a ready-to-use setup with webpack, Babel, and other necessary dependencies. To create a React app using CRA, you can run the following command:


`npx create-react-app my-app`
This will create a new directory called my-app with the basic structure and configuration files for a React project.

`Manual Configuration:`
Alternatively, you can manually set up your development environment by configuring webpack, Babel, and other necessary dependencies yourself. This approach gives you more flexibility and control over the configuration, but it requires more effort and knowledge of the underlying tools.

`CDN Links`
Regarding the use of CDN links for React, while it is possible to include React and ReactDOM using CDN links in your HTML file, it is generally not recommended for building complex web applications. 

We were importing the React library from someone else’s CDN using those CDN links, but now we can import the react directly from our 
local machine/server (i.e. from the node modules folder).And we have to change script tags whenever react version get changed.

## Q: What is `npm i react` , `npm i react-dom`, `import React from 'react'`, `import ReactDOM from 'react-dom'`?
`npm i react`:
This command is used to install the React package from the npm (Node Package Manager) registry. It fetches the latest version of the React package and its dependencies and installs them in your project. After installing, you can use the React library in your code.

import React from 'react':
This line of code imports the React library into your JavaScript file. It allows you to use React components, such as React.Component or React.useState(), in your code. By importing React, you can leverage its functionalities for building user interfaces.

import ReactDOM from 'react-dom':
This line of code imports the ReactDOM library into your JavaScript file. ReactDOM is a separate package from React that provides methods for rendering React components to the DOM (Document Object Model). It includes the ReactDOM.render() method, which is used to render a React component to a specified DOM element.



`<script type="module" src="App.js"></script>`:
In this script tag, the type attribute is set to "module". The type="module" attribute indicates that the script contains ECMAScript modules, which are a standard way of organizing and sharing JavaScript code. It allows you to use module syntax in your JavaScript code and take advantage of features like import and export.

The type="module" attribute is necessary to enable the browser to correctly handle and interpret the JavaScript code as an ECMAScript module.

## Q: What is `npx parcel build index.html`?

The command `npx parcel build index.html` is used to build your project with Parcel. It creates a production-ready bundle of your application that is optimized and ready for deployment

## Q: How to add browserlist ?
Add this in package.json
```json
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
    
  },
  "browserslist": [
  "last 2 Chrome versions",
  "last 2 Firefox versions",
  "last 2 iOS versions",
  "IE 11",
  "not IE <= 11"
]

}
```

## Q: How to add scripts for “start” and “build” with parcel commands

To add scripts for "start" and "build" with Parcel commands in your package.json file, you can follow these steps:

Open your package.json file in a text editor.

Locate the "scripts" property or add it if it doesn't exist.

Add the following entries to define the "start" and "build" scripts:
```json
"scripts": {
  "start": "parcel index.html",
  "build": "parcel build index.html"
}
```
Save the package.json file.
With these script entries, you can now use npm run start and npm run build commands to run the respective Parcel commands.

`npm run start`: This command will start the development server using Parcel, which will compile your code and serve it locally. It typically watches for changes and automatically updates the browser with hot module replacement (HMR) functionality for efficient development.

`npm run build`: This command will build your project using Parcel for production deployment. It will optimize and bundle your code into a build directory (usually dist or build) ready for deployment to a web server or hosting platform.
